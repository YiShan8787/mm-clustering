<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <script src="https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
  <script src="../build/roslib.js"></script>

  <script>
    // Connecting to ROS
    // -----------------
    var ros = new ROSLIB.Ros();
    const can = document.createElement("canvas");
    // If there is an error on the backend, an 'error' emit will be emitted.
    ros.on('error', function (error) {
      document.getElementById('connecting').style.display = 'none';
      document.getElementById('connected').style.display = 'none';
      document.getElementById('closed').style.display = 'none';
      document.getElementById('error').style.display = 'inline';
      console.log(error);
    });

    // Find out exactly when we made a connection.
    ros.on('connection', function () {
      console.log('Connection made!');
      document.getElementById('connecting').style.display = 'none';
      document.getElementById('error').style.display = 'none';
      document.getElementById('closed').style.display = 'none';
      document.getElementById('connected').style.display = 'inline';
    });

    ros.on('close', function () {
      console.log('Connection closed.');
      document.getElementById('connecting').style.display = 'none';
      document.getElementById('connected').style.display = 'none';
      document.getElementById('closed').style.display = 'inline';
    });

    // Create a connection to the rosbridge WebSocket server.
    ros.connect('ws://localhost:9090');

    // Publishing a Topic
    // ------------------

    // First, we create a Topic object with details of the topic's name and message type.
    var cmdVel = new ROSLIB.Topic({
      ros: ros,
      name: '/cmd_vel',
      messageType: 'geometry_msgs/Twist'
    });

    // Then we create the payload to be published. The object we pass in to ros.Message matches the
    // fields defined in the geometry_msgs/Twist.msg definition.
    var twist = new ROSLIB.Message({
      linear: {
        x: 0.1,
        y: 0.2,
        z: 0.3
      },
      angular: {
        x: -0.1,
        y: -0.2,
        z: -0.3
      }
    });

    // And finally, publish.
    cmdVel.publish(twist);

    //Subscribing to a Topic
    //----------------------

    // Like when publishing a topic, we first create a Topic object with details of the topic's name
    // and message type. Note that we can call publish or subscribe on the same topic object.
    var image = new ROSLIB.Topic({
      ros: ros,
      //name : '/listener',
      name: '/usb_webcam/image_raw',
      messageType: 'sensor_msgs/Image'
    });

    // Then we add a callback to be called every time a message is published on this topic.
    image.subscribe(function (message) {

      can.width = message.width;
      can.height = message.height;
      const ctx = can.getContext("2d");

      const imgData = ctx.createImageData(message.width, message.height);
      const data = imgData.data;
      const inData = atob(message.data);

      var j = 0; i = 4; // j data in , i data out
      while (j < inData.length) {
        const w1 = inData.charCodeAt(j++);  // read 3 16 bit words represent 1 pixel
        const w2 = inData.charCodeAt(j++);
        const w3 = inData.charCodeAt(j++);
        if (!message.is_bigendian) {
          data[i++] = w1; // red
          data[i++] = w2; // green
          data[i++] = w3; // blue
        } else {
          data[i++] = (w1 >> 8) + ((w1 & 0xFF) << 8);
          data[i++] = (w2 >> 8) + ((w2 & 0xFF) << 8);
          data[i++] = (w3 >> 8) + ((w3 & 0xFF) << 8);
        }
        data[i++] = 255;  // alpha
      }

      ctx.putImageData(imgData, 0, 0);
      document.body.appendChild(can);

      //console.log('listener:')
      console.log(message)
      // If desired, we can unsubscribe from the topic as well.
      //image.unsubscribe();
    });

    function decode64(inbytes, outbytes, record_size, pointRatio) {
    var x,b=0,l=0,j=0,L=inbytes.length,A=outbytes.length;
    record_size = record_size || A; // default copies everything (no skipping)
    pointRatio = pointRatio || 1; // default copies everything (no skipping)
    var bitskip = (pointRatio-1) * record_size * 8;
    for(x=0;x<L&&j<A;x++){
        b=(b<<6)+decode64.e[inbytes.charAt(x)];
        l+=6;
        if(l>=8){
            l-=8;
            outbytes[j++]=(b>>>l)&0xff;
            if((j % record_size) === 0) { // skip records
                // no    optimization: for(var i=0;i<bitskip;x++){l+=6;if(l>=8) {l-=8;i+=8;}}
                // first optimization: for(;l<bitskip;l+=6){x++;} l=l%8;
                x += Math.ceil((bitskip - l) / 6);
                l = l % 8;
                if(l>0){b=decode64.e[inbytes.charAt(x)];}
            }
        }
    }
    return Math.floor(j/record_size);
    }
    // initialize decoder with static lookup table 'e'
    decode64.S='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    decode64.e={};
    for(var i=0;i<64;i++){decode64.e[decode64.S.charAt(i)]=i;}
    console.log(decode64.e)

    var listener = new ROSLIB.Topic({
      ros: ros,
      //name : '/listener',
      name: '/my_pcl_topic',
      messageType: 'sensor_msgs/PointCloud2'
    });

    listener.subscribe(function (message) {
      var buffer = null
      var bufSz = 10000 * message.point_step
      console.log(message)
      if (message.data.buffer) {
        buffer = message.data.slice(0, Math.min(message.data.byteLength, bufSz));
        n = Math.min(message.height*message.width , this.points.positions.array.length / 3);
      } else {
        if (!buffer || buffer.byteLength < bufSz) {
          buffer = new Uint8Array(bufSz);
        }
        n = decode64(message.data, buffer, message.point_step, 1);
        pointRatio = 1;
      }
      var dv = new DataView(buffer.buffer);
      var littleEndian = !message.is_bigendian;
      var x = message.fields[0].offset;
      var y = message.fields[1].offset;
      var z = message.fields[2].offset;
      var base, color;
      console.log(dv)
      for(var i = 0; i < n; i++){
        base = i * pointRatio * message.point_step;
        console.log(dv.getFloat32(base+x, littleEndian))
        console.log(dv.getFloat32(base+y, littleEndian))
        console.log(dv.getFloat32(base+z, littleEndian))
        
      }
    //n = decode64(message.data, this.buffer, message.point_step, pointRatio = 1);
    //console.log('listener:')
    console.log(n)
    // If desired, we can unsubscribe from the topic as well.
    listener.unsubscribe();
    });

    // Calling a service
    // -----------------

    // First, we create a Service client with details of the service's name and service type.
    var addTwoIntsClient = new ROSLIB.Service({
      ros: ros,
      name: '/add_two_ints',
      serviceType: 'rospy_tutorials/AddTwoInts'
    });

    // Then we create a Service Request. The object we pass in to ROSLIB.ServiceRequest matches the
    // fields defined in the rospy_tutorials AddTwoInts.srv file.
    var request = new ROSLIB.ServiceRequest({
      a: 1,
      b: 2
    });

    // Finally, we call the /add_two_ints service and get back the results in the callback. The result
    // is a ROSLIB.ServiceResponse object.
    addTwoIntsClient.callService(request, function (result) {
      console.log('Result for service call on ' + addTwoIntsClient.name + ': ' + result.sum);
    });

    // Advertising a Service
    // ---------------------

    // The Service object does double duty for both calling and advertising services
    var setBoolServer = new ROSLIB.Service({
      ros: ros,
      name: '/set_bool',
      serviceType: 'std_srvs/SetBool'
    });

    // Use the advertise() method to indicate that we want to provide this service
    setBoolServer.advertise(function (request, response) {
      console.log('Received service request on ' + setBoolServer.name + ': ' + request.data);
      response['success'] = true;
      response['message'] = 'Set successfully';
      return true;
    });

    // Setting a param value
    // ---------------------

    ros.getParams(function (params) {
      console.log(params);
    });

    // First, we create a Param object with the name of the param.
    var maxVelX = new ROSLIB.Param({
      ros: ros,
      name: 'max_vel_y'
    });

    //Then we set the value of the param, which is sent to the ROS Parameter Server.
    maxVelX.set(0.8);
    maxVelX.get(function (value) {
      console.log('MAX VAL: ' + value);
    });

    // Getting a param value
    // ---------------------

    var favoriteColor = new ROSLIB.Param({
      ros: ros,
      name: 'favorite_color'
    });

    favoriteColor.set('red');
    favoriteColor.get(function (value) {
      console.log('My robot\'s favorite color is ' + value);
    });
  </script>
</head>

<body>
  <h1>Simple roslib Example</h1>
  <p>Run the following commands in the terminal then refresh this page. Check the JavaScript
    console for the output.</p>
  <ol>
    <li><tt>roscore</tt></li>
    <li><tt>rostopic pub /listener std_msgs/String "Hello, World"</tt></li>
    <li><tt>rostopic echo /cmd_vel</tt></li>
    <li><tt>rosrun rospy_tutorials add_two_ints_server</tt></li>
    <li><tt>roslaunch rosbridge_server rosbridge_websocket.launch</tt></li>
  </ol>
  <div id="statusIndicator">
    <p id="connecting">
      Connecting to rosbridge...
    </p>
    <p id="connected" style="color:#00D600; display:none">
      Connected
    </p>
    <p id="error" style="color:#FF0000; display:none">
      Error in the backend!
    </p>
    <p id="closed" style="display:none">
      Connection closed.
    </p>
  </div>
</body>

</html>